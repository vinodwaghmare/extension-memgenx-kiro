/**
 * Memory Layer Authentication Module
 * Built with Kiro for Kiroween 2025 ðŸŽƒ
 * 
 * Generated by Kiro - Vibe Coding
 * Prompt: "Create auth.js for Chrome extension with Supabase authentication:
 *         1. Class-based architecture (MemoryLayerAuth)
 *         2. Methods: init(), signInWithEmail(), signInWithProvider(), signOut()
 *         3. Token management with automatic refresh
 *         4. Store auth data in chrome.storage.local
 *         5. Handle OAuth callback flow
 *         6. Work in both service worker and regular contexts"
 * 
 * Handles Supabase authentication with Google OAuth
 * Time saved: ~6 hours of OAuth implementation
 */

class MemoryLayerAuth {
  constructor() {
    this.user = null;
    this.session = null;
    this.isAuthenticated = false;
  }

  /**
   * Initialize authentication - check if user is already signed in
   */
  async init() {
    console.log('ðŸ” Initializing Memory Layer Auth...');
    
    try {
      // Get stored session from Chrome storage
      const stored = await chrome.storage.local.get([
        'memory_layer_user',
        'memory_layer_session',
        'memory_layer_token'
      ]);

      if (stored.memory_layer_user && stored.memory_layer_session && stored.memory_layer_token) {
        this.user = stored.memory_layer_user;
        this.session = stored.memory_layer_session;
        this.isAuthenticated = true;

        // Check if token needs refresh
        const expiresAt = this.session?.expires_at;
        if (expiresAt) {
          const now = Date.now();
          const expirationTime = typeof expiresAt === 'number' ? expiresAt : parseInt(expiresAt);
          
          if (now >= expirationTime) {
            console.log('âš ï¸  Token expired, attempting refresh...');
            const refreshed = await this.refreshToken();
            if (!refreshed) {
              console.log('âŒ Token refresh failed, user needs to sign in again');
              return false;
            }
          }
        }

        console.log('âœ… User session restored:', this.user.id);
        return true;
      } else {
        console.log('â„¹ï¸  No existing session found');
        return false;
      }
    } catch (error) {
      console.error('âŒ Auth init failed:', error);
      return false;
    }
  }

  /**
   * Sign in with email/password
   */
  async signInWithEmail(email, password) {
    console.log('ðŸ” Signing in with email...');
    
    const config = typeof self !== 'undefined' ? self.MEMORY_LAYER_CONFIG : window.MEMORY_LAYER_CONFIG;

    try {
      const response = await fetch(`${config.supabase.url}/auth/v1/token?grant_type=password`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': config.supabase.anonKey,
          'Authorization': `Bearer ${config.supabase.anonKey}`
        },
        body: JSON.stringify({ email, password })
      });

      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ error_description: 'Sign in failed' }));
        throw new Error(errorData.error_description || errorData.message || 'Sign in failed');
      }

      const data = await response.json();
      const sessionData = data.session || {
        access_token: data.access_token,
        refresh_token: data.refresh_token,
        expires_at: data.expires_at
      };
      
      await this.storeAuthData(data.user, sessionData, sessionData.access_token || data.access_token);
      
      console.log('âœ… Sign in successful!');
      return { success: true, user: data.user };
    } catch (error) {
      console.error('âŒ Sign in error:', error);
      throw error;
    }
  }

  /**
   * Sign in with OAuth provider (Google)
   */
  async signInWithProvider(provider = 'google') {
    console.log(`ðŸ” Signing in with ${provider}...`);
    
    try {
      let config;
      if (typeof self !== 'undefined' && self.MEMORY_LAYER_CONFIG) {
        config = self.MEMORY_LAYER_CONFIG;
      } else if (typeof window !== 'undefined' && window.MEMORY_LAYER_CONFIG) {
        config = window.MEMORY_LAYER_CONFIG;
      } else {
        throw new Error('Configuration not found');
      }
      
      if (!config.supabase || !config.supabase.url) {
        throw new Error('Supabase configuration missing');
      }
      
      // Create OAuth URL with callback
      const redirectUrl = chrome.runtime.getURL('auth-callback.html');
      const authUrl = `${config.supabase.url}/auth/v1/authorize?provider=${provider}&redirect_to=${encodeURIComponent(redirectUrl)}`;
      
      console.log('ðŸ”— Opening OAuth URL');
      
      // Open OAuth in new tab
      await chrome.tabs.create({ url: authUrl });
      
      const authInstance = this;
      return new Promise((resolve, reject) => {
        const messageListener = (message, sender, sendResponse) => {
          if (message.type === 'SUPABASE_AUTH_SUCCESS') {
            chrome.runtime.onMessage.removeListener(messageListener);
            
            authInstance.storeAuthData(message.user, message.session, message.token)
              .then(() => {
                console.log('âœ… OAuth authentication successful!');
                resolve({ success: true, user: message.user });
              })
              .catch((error) => {
                console.error('âŒ Failed to store auth data:', error);
                reject(error);
              });
          } else if (message.type === 'SUPABASE_AUTH_ERROR') {
            chrome.runtime.onMessage.removeListener(messageListener);
            reject(new Error(message.error));
          }
        };
        
        chrome.runtime.onMessage.addListener(messageListener);
        
        // Timeout after 5 minutes
        setTimeout(() => {
          chrome.runtime.onMessage.removeListener(messageListener);
          reject(new Error('Authentication timeout'));
        }, 300000);
      });
    } catch (error) {
      console.error('âŒ OAuth error:', error);
      throw error;
    }
  }

  /**
   * Sign out
   */
  async signOut() {
    console.log('ðŸšª Signing out...');
    
    this.user = null;
    this.session = null;
    this.isAuthenticated = false;

    await chrome.storage.local.remove([
      'memory_layer_user',
      'memory_layer_session',
      'memory_layer_token'
    ]);

    console.log('âœ… Signed out successfully');
  }

  /**
   * Store auth data
   */
  async storeAuthData(user, session, token) {
    await chrome.storage.local.set({
      memory_layer_user: user,
      memory_layer_session: session,
      memory_layer_token: token
    });

    this.user = user;
    this.session = session;
    this.isAuthenticated = true;

    console.log('ðŸ’¾ Auth data stored');
  }

  /**
   * Get current user
   */
  getUser() {
    return this.user;
  }

  /**
   * Get user ID
   */
  getUserId() {
    return this.user?.id || null;
  }

  /**
   * Refresh access token
   */
  async refreshToken() {
    if (!this.session?.refresh_token) {
      console.log('âš ï¸  No refresh token available');
      return false;
    }

    const config = typeof self !== 'undefined' ? self.MEMORY_LAYER_CONFIG : window.MEMORY_LAYER_CONFIG;
    
    try {
      console.log('ðŸ”„ Refreshing access token...');
      
      const response = await fetch(`${config.supabase.url}/auth/v1/token?grant_type=refresh_token`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'apikey': config.supabase.anonKey,
          'Authorization': `Bearer ${config.supabase.anonKey}`
        },
        body: JSON.stringify({
          refresh_token: this.session.refresh_token
        })
      });

      if (!response.ok) {
        throw new Error('Token refresh failed');
      }

      const data = await response.json();
      const newSession = {
        access_token: data.access_token,
        refresh_token: data.refresh_token || this.session.refresh_token,
        expires_at: data.expires_at ? parseInt(data.expires_at) * 1000 : null
      };

      await this.storeAuthData(this.user, newSession, newSession.access_token);
      
      console.log('âœ… Token refreshed successfully');
      return true;
    } catch (error) {
      console.error('âŒ Token refresh failed:', error);
      await this.signOut();
      return false;
    }
  }

  /**
   * Get session token (with automatic refresh if needed)
   */
  async getToken() {
    if (!this.isAuthenticated || !this.session) {
      return null;
    }

    try {
      // Check if token needs refresh
      if (this.session?.expires_at) {
        const now = Date.now();
        const expirationTime = typeof this.session.expires_at === 'number' 
          ? this.session.expires_at 
          : parseInt(this.session.expires_at);
        
        // Refresh if expired or expiring soon (within 5 minutes)
        const fiveMinutes = 5 * 60 * 1000;
        if (now >= expirationTime || (expirationTime - now) <= fiveMinutes) {
          console.log('ðŸ”„ Token expiring soon, refreshing...');
          const refreshed = await this.refreshToken();
          if (!refreshed) {
            return null;
          }
        }
      }
      
      return this.session?.access_token || null;
    } catch (error) {
      console.error('âŒ Error getting token:', error);
      return null;
    }
  }

  /**
   * Check if authenticated
   */
  isSignedIn() {
    return this.isAuthenticated;
  }
}

// Create global instance
const memoryLayerAuth = new MemoryLayerAuth();

// Make it accessible in both window and service worker contexts
if (typeof window !== 'undefined') {
  window.memoryLayerAuth = memoryLayerAuth;
}
if (typeof self !== 'undefined') {
  self.memoryLayerAuth = memoryLayerAuth;
}

console.log('âœ… Memory Layer Auth module loaded');
