/**
 * Memory Layer Background Service Worker
 * Built with Kiro for Kiroween 2025 üéÉ
 * 
 * Generated by Kiro - Vibe Coding
 * Prompt: "Create background.js service worker for Chrome extension:
 *         1. Import config.js and auth.js with importScripts
 *         2. Initialize auth on startup
 *         3. Handle messages from content scripts and popup
 *         4. API functions: savePrompt(), saveResponse(), getContext()
 *         5. Proper message passing with sendResponse
 *         6. Error handling and logging"
 * 
 * Handles:
 * - Authentication state management
 * - API communication with backend
 * - Message passing between content scripts and popup
 * 
 * Time saved: ~5 hours of service worker implementation
 */

importScripts('config.js');
importScripts('auth.js');

console.log('üéÉ Memory Layer Background Service Worker starting...');

// Get auth instance
const auth = typeof self !== 'undefined' ? self.memoryLayerAuth : memoryLayerAuth;

// Initialize on startup
(async function() {
  console.log('üöÄ Initializing Memory Layer...');
  await auth.init();
  console.log('‚úÖ Auth initialized:', auth.isSignedIn() ? 'Authenticated' : 'Not authenticated');
})();

// Initialize on install
chrome.runtime.onInstalled.addListener(async (details) => {
  console.log('üì¶ Memory Layer installed/updated:', details.reason);
  await auth.init();
  
  if (details.reason === 'install') {
    console.log('üéâ Welcome to Memory Layer!');
    // Open welcome page
    chrome.action.openPopup();
  }
});

// Initialize on startup
chrome.runtime.onStartup.addListener(async () => {
  console.log('üöÄ Memory Layer starting...');
  await auth.init();
});

// Handle messages from content scripts and popup
chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
  // Handle OAuth callback
  if (message.type === 'SUPABASE_AUTH_SUCCESS') {
    auth.storeAuthData(message.user, message.session, message.token)
      .then(() => {
        console.log('‚úÖ Auth data stored from callback');
        sendResponse({ success: true });
      })
      .catch((error) => {
        console.error('‚ùå Failed to store auth data:', error);
        sendResponse({ success: false, error: error.message });
      });
    return true;
  }
  
  if (message.type === 'SUPABASE_AUTH_ERROR') {
    console.error('‚ùå OAuth error from callback:', message.error);
    sendResponse({ success: false, error: message.error });
    return true;
  }
  
  // Handle other messages
  handleMessage(message, sender, sendResponse);
  return true; // Keep channel open for async response
});

/**
 * Main message handler
 */
async function handleMessage(message, sender, sendResponse) {
  console.log('üì® Message received:', message.type);
  
  // Ensure auth is initialized for auth-dependent operations
  if (['SAVE_PROMPT', 'SAVE_RESPONSE', 'GET_CONTEXT', 'GET_TOKEN', 'GET_USER_ID'].includes(message.type)) {
    if (!auth.isAuthenticated) {
      await auth.init();
    }
  }
  
  try {
    switch (message.type) {
      case 'GET_AUTH_STATUS':
        if (!auth.isAuthenticated) {
          await auth.init();
        }
        sendResponse({
          isAuthenticated: auth.isSignedIn(),
          user: auth.getUser()
        });
        break;

      case 'GET_USER_ID':
        sendResponse({ userId: auth.getUserId() });
        break;

      case 'GET_TOKEN':
        try {
          const token = await auth.getToken();
          sendResponse({ token: token });
        } catch (error) {
          console.error('‚ùå Get token error:', error);
          sendResponse({ token: null, error: error.message });
        }
        break;

      case 'IS_AUTHENTICATED':
        sendResponse({ isAuthenticated: auth.isSignedIn() });
        break;

      case 'SIGN_IN_EMAIL':
        try {
          const result = await auth.signInWithEmail(message.email, message.password);
          sendResponse({ success: true, user: result.user });
        } catch (error) {
          sendResponse({ success: false, error: error.message });
        }
        break;

      case 'SIGN_IN_PROVIDER':
        try {
          const result = await auth.signInWithProvider(message.provider);
          sendResponse({ success: true, user: result.user });
        } catch (error) {
          sendResponse({ success: false, error: error.message });
        }
        break;

      case 'SIGN_OUT':
        await auth.signOut();
        sendResponse({ success: true });
        break;

      case 'SAVE_PROMPT':
        const savedPrompt = await savePrompt(message.data);
        sendResponse(savedPrompt);
        break;

      case 'SAVE_RESPONSE':
        const savedResponse = await saveResponse(message.data);
        sendResponse(savedResponse);
        break;

      case 'GET_CONTEXT':
        const context = await getContext(message.query);
        sendResponse(context);
        break;

      default:
        console.warn('‚ö†Ô∏è  Unknown message type:', message.type);
        sendResponse({ error: 'Unknown message type' });
    }
  } catch (error) {
    console.error('‚ùå Message handler error:', error);
    sendResponse({ error: error.message });
  }
}

/**
 * Save user prompt to backend
 */
async function savePrompt(data) {
  if (!auth.isSignedIn()) {
    console.error('‚ùå User not authenticated');
    return { success: false, error: 'Not authenticated' };
  }

  const userId = auth.getUserId();
  const token = await auth.getToken();
  
  if (!userId || !token) {
    console.error('‚ùå Missing userId or token');
    return { success: false, error: 'Not authenticated' };
  }

  try {
    const config = self.MEMORY_LAYER_CONFIG;
    const url = `${config.backend.baseUrl}${config.backend.endpoints.savePrompt}`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        user_id: userId,
        prompt: data.prompt,
        provider: data.provider || 'chatgpt'
      })
    });

    if (response.ok) {
      const result = await response.json();
      console.log('‚úÖ Prompt saved');
      return { success: true, data: result };
    } else {
      const error = await response.text();
      console.error('‚ùå Failed to save prompt:', error);
      return { success: false, error: error };
    }
  } catch (error) {
    console.error('‚ùå Save prompt error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Save AI response to backend
 */
async function saveResponse(data) {
  if (!auth.isSignedIn()) {
    console.error('‚ùå User not authenticated');
    return { success: false, error: 'Not authenticated' };
  }

  const userId = auth.getUserId();
  const token = await auth.getToken();
  
  if (!userId || !token) {
    console.error('‚ùå Missing userId or token');
    return { success: false, error: 'Not authenticated' };
  }

  try {
    const config = self.MEMORY_LAYER_CONFIG;
    const url = `${config.backend.baseUrl}${config.backend.endpoints.saveResponse}`;
    
    const response = await fetch(url, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}`
      },
      body: JSON.stringify({
        user_id: userId,
        prompt: data.prompt,
        response: data.response,
        provider: data.provider || 'chatgpt'
      })
    });

    if (response.ok) {
      const result = await response.json();
      console.log('‚úÖ Response saved');
      return { success: true, data: result };
    } else {
      const error = await response.text();
      console.error('‚ùå Failed to save response:', error);
      return { success: false, error: error };
    }
  } catch (error) {
    console.error('‚ùå Save response error:', error);
    return { success: false, error: error.message };
  }
}

/**
 * Get relevant context from backend
 */
async function getContext(query) {
  if (!auth.isSignedIn()) {
    console.error('‚ùå User not authenticated');
    return { success: false, contexts: [], error: 'Not authenticated' };
  }

  const userId = auth.getUserId();
  const token = await auth.getToken();
  
  if (!userId || !token) {
    console.error('‚ùå Missing userId or token');
    return { success: false, contexts: [], error: 'Not authenticated' };
  }

  try {
    const config = self.MEMORY_LAYER_CONFIG;
    const url = `${config.backend.baseUrl}${config.backend.endpoints.getContext}/${userId}?query=${encodeURIComponent(query)}`;
    
    const response = await fetch(url, {
      method: 'GET',
      headers: {
        'Authorization': `Bearer ${token}`
      }
    });

    if (response.ok) {
      const result = await response.json();
      console.log('‚úÖ Context retrieved:', result.contexts?.length || 0);
      return { 
        success: true, 
        contexts: result.contexts || [],
        count: result.count || 0
      };
    } else {
      const error = await response.text();
      console.error('‚ùå Failed to get context:', error);
      return { success: false, contexts: [], error: error };
    }
  } catch (error) {
    console.error('‚ùå Get context error:', error);
    return { success: false, contexts: [], error: error.message };
  }
}

console.log('‚úÖ Memory Layer Background Service Worker ready! üéÉ');
